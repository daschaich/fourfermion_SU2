/*****************  su2_proj.c  (in su2.a) ******************************
*									*
* void su2_projector( su2_vector *a, su2_vector *b, su2_matrix *c )	*
* C  <- outer product of A and B					*
*  C_ij = A_i * B_adjoint_j						*
*/
#include "../include/config.h"
#include "../include/complex.h"
#include "../include/su2.h"

//#ifndef FAST
void su2_projector(vector *a,vector *b, su2_matrix *c ){
register int i,j;
    for(i=0;i<2;i++)for(j=0;j<2;j++){
	CMUL_J( a->c[i], b->c[j], c->e[i][j] );
    }
}

//#else
//#ifdef NATIVEDOUBLE   /* RS6000 version */

/*void su2_projector( su2_vector *a, su2_vector *b, su2_matrix *c ){

  register int i,j;
  register double ar,ai,br,bi;

    for(i=0;i<3;i++){
	ar=a->c[i].real;  ai=a->c[i].imag;
	for(j=0;j<3;j++){
	    br=b->c[j].real;  bi=b->c[j].imag;
	    c->e[i][j].real = ar*br + ai*bi;
	    c->e[i][j].imag = ai*br - ar*bi;
	}
    }
}
#else

void su2_projector( su2_vector *a, su2_vector *b, su2_matrix *c ){
register int i,j;
register Real tmp,tmp2;
    for(i=0;i<3;i++)for(j=0;j<3;j++){
	tmp2 = a->c[i].real * b->c[j].real;
	tmp = a->c[i].imag * b->c[j].imag;
	c->e[i][j].real = tmp + tmp2;
	tmp2 = a->c[i].real * b->c[j].imag;
	tmp = a->c[i].imag * b->c[j].real;
	c->e[i][j].imag = tmp - tmp2;
    }
}

